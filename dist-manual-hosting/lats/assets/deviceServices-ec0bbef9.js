import{s as e}from"./index-222cfb29.js";import{t,a as r}from"./utils-fb833cf6.js";import"./vendor-a2ff445a.js";import"./supabase-7e851d02.js";import"./routing-a2f0f6d2.js";import"./ui-551a39a6.js";import"./charts-66cc82bb.js";class a{constructor(){this.queue=[],this.processing=!1,this.maxConcurrent=2,this.delayBetweenRequests=500}static getInstance(){return a.instance||(a.instance=new a),a.instance}async execute(e){return new Promise((t,r)=>{this.queue.push(async()=>{try{await new Promise(e=>setTimeout(e,this.delayBetweenRequests));const r=await e();t(r)}catch(a){r(a)}}),this.processQueue()})}async processQueue(){if(!this.processing&&0!==this.queue.length){for(this.processing=!0;this.queue.length>0;){const e=this.queue.splice(0,this.maxConcurrent);await Promise.all(e.map(e=>e()))}this.processing=!1}}}const n=["id","customer_id","brand","model","serial_number","issue_description","status","assigned_to","estimated_hours","expected_return_date","warranty_start","warranty_end","warranty_status","repair_count","last_return_date","created_at","updated_at"];const i={async getAllDevices(){try{const r=localStorage.getItem("current_branch_id");let a=e.from("devices").select("\n          id,\n          customer_id,\n          brand,\n          model,\n          serial_number,\n          issue_description,\n          status,\n          assigned_to,\n          estimated_hours,\n          expected_return_date,\n          created_at,\n          updated_at\n        ").order("created_at",{ascending:!1});r&&(a=a.eq("branch_id",r));const{data:n,error:i}=await a;if(i)throw new Error(`Failed to fetch devices: ${i.message}`);return(null==n?void 0:n.map(t))||[]}catch(r){throw new Error("Network error: Unable to connect to database")}},async getDeviceById(r){try{const{data:a,error:n}=await e.from("devices").select("\n          id,\n          customer_id,\n          brand,\n          model,\n          serial_number,\n          issue_description,\n          status,\n          assigned_to,\n          estimated_hours,\n          expected_return_date,\n          created_at,\n          updated_at\n        ").eq("id",r).single();if(n)throw new Error(`Failed to fetch device: ${n.message}`);return t(a)}catch(a){throw new Error("Network error: Unable to connect to database")}},async createDevice(a){try{const i=localStorage.getItem("current_branch_id"),s=function(e){const t={};for(const r of n)void 0!==e[r]&&(t[r]=e[r]);return t}(a),o=r(s),{id:c,...d}=o;d.status||(d.status="received"),d.branch_id=i||"00000000-0000-0000-0000-000000000001";const{data:l,error:u}=await e.from("devices").insert(d).select("*").single();if(u)throw new Error(`Failed to create device: ${u.message}`);return t(l)}catch(i){throw new Error("Network error: Unable to connect to database")}},async updateDevice(t,a){const n=Object.fromEntries(Object.entries(a).map(([e,t])=>[r(e),t])),{data:i,error:s}=await e.from("devices").update(n).eq("id",t).select().single();if(s)throw s;return a.status&&await e.from("device_notifications").insert({device_id:t,type:"info",title:"Device Status Updated",message:`Device status changed to ${a.status}`,sent_at:(new Date).toISOString(),is_read:!1}),i},async deleteDevice(t){try{const{error:r}=await e.from("devices").delete().eq("id",t);if(r)throw new Error(`Failed to delete device: ${r.message}`);return!0}catch(r){throw new Error("Network error: Unable to connect to database")}},async addDeviceChecklist(t){try{const{data:r,error:a}=await e.from("device_checklists").insert(t).select().single();if(a)throw new Error(`Failed to add device checklist: ${a.message}`);return r}catch(r){throw new Error("Network error: Unable to connect to database")}},async updateDeviceChecklist(t,r){try{const{data:a,error:n}=await e.from("device_checklists").update({...r,updated_at:(new Date).toISOString()}).eq("id",t).select().single();if(n)throw new Error(`Failed to update device checklist: ${n.message}`);return a}catch(a){throw new Error("Network error: Unable to connect to database")}},async addDeviceRemark(t){try{const{data:r,error:a}=await e.from("device_remarks").insert(t).select().single();if(a)throw new Error(`Failed to add device remark: ${a.message}`);return await e.from("device_notifications").insert({device_id:t.device_id,type:"info",title:"New Device Remark",message:`A new remark/message was added to device ${t.device_id}.`,sent_at:(new Date).toISOString(),is_read:!1}),r}catch(r){throw new Error("Network error: Unable to connect to database")}},async addDeviceTransition(t){try{const{data:r,error:a}=await e.from("device_transitions").insert(t).select().single();if(a)throw new Error(`Failed to add device transition: ${a.message}`);return await e.from("device_notifications").insert({device_id:t.device_id,type:"info",title:"Device Status Updated",message:`Device ${t.device_id} status changed from ${t.from_status} to ${t.to_status}.`,sent_at:(new Date).toISOString(),is_read:!1}),r}catch(r){throw new Error("Network error: Unable to connect to database")}},async addDeviceRating(t){try{const{data:r,error:a}=await e.from("device_ratings").insert(t).select().single();if(a)throw new Error(`Failed to add device rating: ${a.message}`);return r}catch(r){throw new Error("Network error: Unable to connect to database")}},async searchDevices(r){try{const a=localStorage.getItem("current_branch_id");let n=e.from("devices").select("\n          id,\n          customer_id,\n          brand,\n          model,\n          serial_number,\n          issue_description,\n          status,\n          assigned_to,\n          estimated_hours,\n          expected_return_date,\n          created_at,\n          updated_at\n        ").or(`brand.ilike.%${r}%,model.ilike.%${r}%,serial_number.ilike.%${r}%,id.ilike.%${r}%`).order("created_at",{ascending:!1});a&&(n=n.eq("branch_id",a));const{data:i,error:s}=await n;if(s)throw new Error(`Failed to search devices: ${s.message}`);return t(i||[])}catch(a){throw new Error("Network error: Unable to connect to database")}},async filterDevicesByStatus(r){try{const a=localStorage.getItem("current_branch_id");let n=e.from("devices").select("\n          id,\n          customer_id,\n          brand,\n          model,\n          serial_number,\n          issue_description,\n          status,\n          assigned_to,\n          estimated_hours,\n          expected_return_date,\n          created_at,\n          updated_at\n        ").eq("status",r).order("created_at",{ascending:!1});a&&(n=n.eq("branch_id",a));const{data:i,error:s}=await n;if(s)throw new Error(`Failed to filter devices: ${s.message}`);return t(i||[])}catch(a){throw new Error("Network error: Unable to connect to database")}},async getDevicesByTechnician(r){try{const a=localStorage.getItem("current_branch_id");let n=e.from("devices").select("\n          id,\n          customer_id,\n          brand,\n          model,\n          serial_number,\n          issue_description,\n          status,\n          assigned_to,\n          estimated_hours,\n          expected_return_date,\n          created_at,\n          updated_at\n        ").eq("assigned_to",r).order("created_at",{ascending:!1});a&&(n=n.eq("branch_id",a));const{data:i,error:s}=await n;if(s)throw new Error(`Failed to fetch devices: ${s.message}`);return t(i||[])}catch(a){throw new Error("Network error: Unable to connect to database")}},async getDevicesByCustomer(r){try{const n=a.getInstance();return await n.execute(async()=>{const a=localStorage.getItem("current_branch_id");let n=e.from("devices").select("\n            id,\n            customer_id,\n            brand,\n            model,\n            serial_number,\n            issue_description,\n            status,\n            assigned_to,\n            estimated_hours,\n            expected_return_date,\n            created_at,\n            updated_at\n          ").eq("customer_id",r).order("created_at",{ascending:!1});a&&(n=n.eq("branch_id",a));const{data:i,error:s}=await n;if(s)throw new Error(`Failed to fetch devices: ${s.message}`);return t(i||[])})}catch(n){throw new Error("Network error: Unable to connect to database")}},async getDevicePaymentRecords(r){try{const{data:a,error:n}=await e.from("customer_payments").select("\n          *,\n          devices(brand, model)\n        ").eq("device_id",r).order("payment_date",{ascending:!1});if(n)throw new Error(`Failed to fetch payment records: ${n.message}`);const i=(a||[]).map(e=>{var t;return{...e,device_name:e.devices?`${e.devices.brand||""} ${e.devices.model||""}`.trim():void 0,customer_name:(null==(t=e.customers)?void 0:t.name)||void 0}});return t(i)}catch(a){throw new Error("Network error: Unable to connect to database")}},async getCustomerPaymentRecords(r){try{const{data:a,error:n}=await e.from("customer_payments").select("\n          *,\n          devices(brand, model)\n        ").eq("customer_id",r).order("payment_date",{ascending:!1});if(n)return[];const i=(a||[]).map(e=>({...e,device_name:e.devices?`${e.devices.brand||""} ${e.devices.model||""}`.trim():void 0}));return t(i)}catch(a){return[]}},async addPaymentRecord(r){try{if(!r.customer_id)throw new Error("Customer ID is required for payment record");const{data:a,error:n}=await e.from("customer_payments").insert([r]).select().single();if(n)throw new Error(`Failed to add payment record: ${n.message}`);return await e.from("device_notifications").insert({device_id:r.device_id,type:"failed"===r.status?"error":"info",title:"failed"===r.status?"Payment Failed":"Payment Received",message:"failed"===r.status?`A payment for device ${r.device_id} failed.`:`Payment received for device ${r.device_id}.`,sent_at:(new Date).toISOString(),is_read:!1}),t(a)}catch(a){throw new Error("Network error: Unable to connect to database")}},async getDeviceStatistics(){try{const t=localStorage.getItem("current_branch_id");let r=e.from("devices").select("id",{count:"exact"}),a=e.from("devices").select("id",{count:"exact"}).in("status",["received","in_progress"]),n=e.from("devices").select("id",{count:"exact"}).eq("status","completed"),i=e.from("devices").select("id",{count:"exact"}).eq("status","completed");t&&(r=r.eq("branch_id",t),a=a.eq("branch_id",t),n=n.eq("branch_id",t),i=i.eq("branch_id",t));const{data:s,error:o}=await r,{data:c,error:d}=await a,{data:l,error:u}=await n,{data:m,error:_}=await i;if(o||d||u||_)throw new Error("Failed to fetch device statistics");return{totalDevices:(null==s?void 0:s.length)||0,inRepair:(null==c?void 0:c.length)||0,readyForPickup:(null==l?void 0:l.length)||0,completed:(null==m?void 0:m.length)||0}}catch(t){throw new Error("Network error: Unable to connect to database")}},async getTechnicianRating(t){try{const{data:r,error:a}=await e.from("device_ratings").select("*").eq("technician_id",t);if(a)throw new Error(`Failed to get technician rating: ${a.message}`);if(!r||0===r.length)return 0;return r.reduce((e,t)=>e+(t.score||5),0)/r.length}catch(r){throw new Error("Network error: Unable to connect to database")}},async updateDeviceReturnDate(r,a){try{const{data:n,error:i}=await e.from("devices").update({expected_return_date:a,updated_at:(new Date).toISOString()}).eq("id",r).select().single();if(i)throw new Error(`Failed to update device return date: ${i.message}`);return t(n)}catch(n){throw new Error("Network error: Unable to connect to database")}},async sendCustomerNotification(t,r){try{const{error:a}=await e.from("device_notifications").insert({device_id:t,message:r,sent_at:(new Date).toISOString(),is_read:!1});if(a)throw a;return!0}catch(a){return!1}},async assignTechnicianToDevice(r,a){try{const{data:n,error:i}=await e.from("devices").update({assigned_to:a,updated_at:(new Date).toISOString()}).eq("id",r).select("\n          id,\n          customer_id,\n          brand,\n          model,\n          serial_number,\n          issue_description,\n          status,\n          assigned_to,\n          estimated_hours,\n          expected_return_date,\n          created_at,\n          updated_at\n        ").single();if(i)throw new Error(`Failed to assign technician: ${i.message}`);return await e.from("device_notifications").insert({device_id:r,type:"info",title:"Technician Assigned",message:`A technician has been assigned to device ${r}.`,sent_at:(new Date).toISOString(),is_read:!1}),t(n)}catch(n){throw new Error("Network error: Unable to assign technician")}},async saveReceipt(r){try{const{data:a,error:n}=await e.from("receipts").insert({receipt_number:`RCP-${Date.now()}-${Math.random().toString(36).substr(2,9).toUpperCase()}`,device_id:r.deviceId,customer_id:r.customerId,payment_id:r.paymentId,technician_id:r.technicianId,device_brand:r.deviceBrand,device_model:r.deviceModel,device_serial_number:r.deviceSerialNumber,device_issue:r.deviceIssue,customer_name:r.customerName,customer_phone:r.customerPhone,customer_email:r.customerEmail,payment_method:r.paymentMethod,payment_reference:r.paymentReference,payment_amount:r.paymentAmount,total_cost:r.totalCost,deposit_amount:r.depositAmount,remaining_balance:r.remainingBalance,repair_cost:r.repairCost,labor_cost:r.laborCost,parts_cost:r.partsCost,device_status:r.deviceStatus,generated_by:r.generatedBy,receipt_content:r.receiptContent}).select().single();if(n)throw new Error(`Failed to save receipt: ${n.message}`);return t(a)}catch(a){throw new Error("Network error: Unable to connect to database")}},async getReceipt(r){try{const{data:a,error:n}=await e.from("receipts").select("*").eq("id",r).single();if(n)throw new Error(`Failed to fetch receipt: ${n.message}`);if(!a)throw new Error("Receipt not found");const[i,s,o]=await Promise.all([a.device_id?e.from("devices").select("*").eq("id",a.device_id).single():Promise.resolve({data:null,error:null}),a.customer_id?e.from("customers").select("*").eq("id",a.customer_id).single():Promise.resolve({data:null,error:null}),e.from("customer_payments").select("*").eq("receipt_id",r)]),c={...a,devices:i.data,customers:s.data,customer_payments:o.data||[]};return t(c)}catch(a){throw new Error("Network error: Unable to connect to database")}},async getDeviceReceipts(r){var a,n;try{const{data:i,error:s}=await e.from("receipts").select("*").eq("device_id",r).order("receipt_date",{ascending:!1});if(s)throw new Error(`Failed to fetch device receipts: ${s.message}`);if(!i||0===i.length)return[];const o=i.map(e=>e.customer_id).filter(Boolean),c=i.map(e=>e.id),[d,l]=await Promise.all([o.length>0?e.from("customers").select("*").in("id",o):Promise.resolve({data:[],error:null}),e.from("customer_payments").select("*").in("receipt_id",c)]),u=new Map((null==(a=d.data)?void 0:a.map(e=>[e.id,e]))||[]),m=new Map;null==(n=l.data)||n.forEach(e=>{const t=m.get(e.receipt_id)||[];t.push(e),m.set(e.receipt_id,t)});const _=i.map(e=>({...e,customers:e.customer_id?u.get(e.customer_id):null,customer_payments:m.get(e.id)||[]}));return t(_)}catch(i){throw new Error("Network error: Unable to connect to database")}},async getCustomerReceipts(r){try{const{data:a,error:n}=await e.from("receipts").select("\n          *,\n          devices(*),\n          customer_payments(*),\n          auth_users!receipts_technician_id_fkey(*)\n        ").eq("customer_id",r).order("receipt_date",{ascending:!1});if(n)throw new Error(`Failed to fetch customer receipts: ${n.message}`);return t(a||[])}catch(a){throw new Error("Network error: Unable to connect to database")}},async markReceiptPrinted(r){try{const{data:a,error:n}=await e.from("receipts").update({is_printed:!0}).eq("id",r).select().single();if(n)throw new Error(`Failed to mark receipt as printed: ${n.message}`);return t(a)}catch(a){throw new Error("Network error: Unable to connect to database")}},async markReceiptSent(r,a){try{const{data:n,error:i}=await e.from("receipts").update({is_sent_to_customer:!0,sent_via:a,sent_at:(new Date).toISOString()}).eq("id",r).select().single();if(i)throw new Error(`Failed to mark receipt as sent: ${i.message}`);return t(n)}catch(n){throw new Error("Network error: Unable to connect to database")}}},s={subscribeToDevices(t){try{return e.channel("devices").on("postgres_changes",{event:"*",schema:"public",table:"devices"},t).subscribe(e=>{})}catch(r){return null}},subscribeToDeviceChecklists(t){try{return e.channel("device_checklists").on("postgres_changes",{event:"*",schema:"public",table:"device_checklists"},t).subscribe(e=>{})}catch(r){return null}},subscribeToDeviceRemarks(t){try{return e.channel("device_remarks").on("postgres_changes",{event:"*",schema:"public",table:"device_remarks"},t).subscribe(e=>{})}catch(r){return null}},subscribeToDeviceTransitions(t){try{return e.channel("device_transitions").on("postgres_changes",{event:"*",schema:"public",table:"device_transitions"},t).subscribe(e=>{})}catch(r){return null}},subscribeToDevice(t,r){try{return e.channel(`device_${t}`).on("postgres_changes",{event:"*",schema:"public",table:"devices",filter:`id=eq.${t}`},r).subscribe(e=>{})}catch(a){return null}},subscribeToDeviceNotifications(t){try{return e.channel("device_notifications").on("postgres_changes",{event:"*",schema:"public",table:"device_notifications"},t).subscribe(e=>{})}catch(r){return null}}},o={async notifyInventoryLow(t){await e.from("device_notifications").insert({type:"warning",title:"Low Inventory",message:`${t} is low on stock.`,sent_at:(new Date).toISOString(),is_read:!1})},async notifyInventoryOut(t){await e.from("device_notifications").insert({type:"error",title:"Out of Stock",message:`${t} is out of stock!`,sent_at:(new Date).toISOString(),is_read:!1})},async notifyInventoryNew(t){await e.from("device_notifications").insert({type:"info",title:"New Inventory Item",message:`New item added: ${t}`,sent_at:(new Date).toISOString(),is_read:!1})},async notifyWarrantyExpiring(t){await e.from("device_notifications").insert({type:"warning",title:"Warranty Expiry Soon",message:`Warranty for device ${t} expires soon.`,sent_at:(new Date).toISOString(),is_read:!1})},async notifyWarrantyExpired(t){await e.from("device_notifications").insert({type:"error",title:"Warranty Expired",message:`Warranty for device ${t} has expired.`,sent_at:(new Date).toISOString(),is_read:!1})},async notifySystemError(t){await e.from("device_notifications").insert({type:"error",title:"System Error",message:`A critical system error occurred: ${t}`,sent_at:(new Date).toISOString(),is_read:!1})},async notifySystemMaintenance(t){await e.from("device_notifications").insert({type:"info",title:"System Maintenance",message:`System maintenance scheduled for ${t}.`,sent_at:(new Date).toISOString(),is_read:!1})}};export{i as deviceServices,s as deviceSubscriptions,o as notificationHelpers};
